{"version":3,"file":"jwt.mjs","names":["service","YError","ms","jwt","DEFAULT_JWT_SECRET_ENV_NAME","initJWT","JWT_SECRET_ENV_NAME","ENV","JWT","time","Date","now","bind","log","noop","JWT_DURATION","readMS","duration","JWT_TOLERANCE","tolerance","secretName","secretEnvName","jwtSecret","algorithms","length","jwtService","sign","verify","payload","algorithm","issuedAt","expiresAt","validAt","includes","token","Promise","resolve","reject","JSON","stringify","iat","Math","floor","exp","nbf","err","wrap","clockTolerance","clockTimestamp","decoded","name","args","value","errorCode","defaultValue","undefined","isRequired","hasValue","finalValue","computedDuration"],"sources":["../src/jwt.ts"],"sourcesContent":["import { Dependencies, Service, service, ServiceInitializer } from 'knifecycle';\nimport YError from 'yerror';\nimport ms from 'ms';\nimport jwt from 'jsonwebtoken';\nimport type { SignOptions, Algorithm } from 'jsonwebtoken';\nimport type { LogService, TimeService } from 'common-services';\n\nexport const DEFAULT_JWT_SECRET_ENV_NAME = 'JWT_SECRET';\n\nexport interface JWT_CONFIG<\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n> {\n  secretEnvName?: T;\n  duration: string;\n  tolerance?: string;\n  algorithms: Array<string>;\n}\n\nexport type JWT_ENV<\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n> = Record<T, string>;\n\n/**\n@typedef JWTSignResult\n*/\nexport type JWTSignResult = {\n  token: string;\n  issuedAt: number;\n  expiresAt: number;\n  validAt: number;\n};\n\nexport interface JWTService<PAYLOAD extends Record<string, unknown>> {\n  sign: (payload: PAYLOAD, algorithm?: string) => Promise<JWTSignResult>;\n  verify: (token: string) => Promise<PAYLOAD>;\n}\n\nexport type JWTServiceConfig<\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n> = {\n  JWT_SECRET_ENV_NAME?: T;\n  JWT: JWT_CONFIG<T>;\n};\n\nexport type JWTServiceDependencies<\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n> = JWTServiceConfig<T> & {\n  ENV?: JWT_ENV<T>;\n  time?: TimeService;\n  log?: LogService;\n};\n\nexport interface JWTServiceInitializer<\n  PAYLOAD extends Record<string, unknown>,\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n> {\n  (dependencies: JWTServiceDependencies<T>): Promise<JWTService<PAYLOAD>>;\n}\n\n/* Architecture Note #1: JWT service\n\nThis JWT service is a simple wrapper around the `jsonwebtoken` NPM\n module. It adds a level of abstraction simply providing a way to\n sign and verify JSON Web Tokens in my apps.\n\nIt also cast errors with `YError` ones and adds a tolerance for\n expired tokens so that clock drifts between instances won't be\n a problem.\n\n It also uses `Knifecycle` for a drop in dependency injection\n support in projects using Knifecycle.\n\nFinally, it deal with promises which are more convenient than the\n original API.\n*/\n\nexport default service(\n  initJWT as unknown as ServiceInitializer<Dependencies, Service>,\n  'jwt',\n  ['?JWT_SECRET_ENV_NAME', '?ENV', 'JWT', '?log', '?time'],\n) as typeof initJWT;\n\n/**\n * Instantiate the JWT service\n * @function\n * @param  {Object}     services\n * The services to inject\n * @param  {Function}   [services.JWT_SECRET_ENV_NAME]\n * The environment variable name in which to pick-up the\n *  JWT secret\n * @param  {Object}   [services.ENV]\n * An environment object\n * @param  {Function}   services.JWT\n * The JWT service configuration object\n * @param  {Function}   [services.log]\n * A logging function\n * @param  {Function}   [services.time]\n * A function returning the current timestamp\n * @return {Promise<JWTService>}\n * A promise of the jwt service\n * @example\n * import initJWTService from 'jwt-service';\n *\n * const jwt = await initJWTService({\n *   JWT: {\n *     secret: 'secret',\n *     duration: '2d',\n *     tolerance: '2h',\n *     algorithms: ['HS256'],\n *   },\n *   log: console.log.bind(console),\n *   time: Date.now.bind(Date),\n * });\n *\n * const token = await jwt.sign({ my: 'payload' });\n */\nasync function initJWT<\n  PAYLOAD extends Record<string, unknown>,\n  T extends string extends T\n    ? never\n    : string = typeof DEFAULT_JWT_SECRET_ENV_NAME,\n>({\n  JWT_SECRET_ENV_NAME,\n  ENV,\n  JWT,\n  time = Date.now.bind(Date),\n  log = noop,\n}: JWTServiceDependencies<T>): Promise<JWTService<PAYLOAD>> {\n  const JWT_DURATION = readMS(JWT.duration, 'E_BAD_JWT_DURATION');\n  const JWT_TOLERANCE = readMS(JWT.tolerance, 'E_BAD_JWT_TOLERANCE', 0);\n  const secretName =\n    JWT_SECRET_ENV_NAME ||\n    JWT.secretEnvName ||\n    (DEFAULT_JWT_SECRET_ENV_NAME as T);\n  const jwtSecret = ENV?.[secretName] as string;\n\n  if (!jwtSecret) {\n    throw new YError('E_NO_JWT_SECRET');\n  }\n  if (!(JWT.algorithms && JWT.algorithms.length)) {\n    throw new YError('E_NO_JWT_ALGORITHMS');\n  }\n\n  /**\n   * @typedef JWTService\n   */\n  const jwtService: JWTService<PAYLOAD> = {\n    sign,\n    verify,\n  };\n\n  /**\n   * Sign the given payload\n   * @memberof JWTService\n   * @param  {Object}   payload      The payload to sign\n   * @param  {String}   [algorithm]  The signing algorithm\n   * @return {Promise<JWTSignResult>}\n   * A promise to be resolved with the signed token.\n   * @example\n   * const token = await jwt.sign({ my: 'payload' });\n   */\n  async function sign(\n    payload: PAYLOAD,\n    algorithm: string = JWT.algorithms[0],\n  ): Promise<JWTSignResult> {\n    const issuedAt = time();\n    const expiresAt = issuedAt + JWT_DURATION;\n    const validAt = issuedAt;\n\n    if (!JWT.algorithms.includes(algorithm)) {\n      throw new YError('E_UNKNOWN_ALGORYTHM', algorithm, JWT.algorithms);\n    }\n\n    const token = await new Promise<string>((resolve, reject) => {\n      jwt.sign(\n        JSON.stringify({\n          ...payload,\n          iat: Math.floor(issuedAt / 1000),\n          exp: Math.floor(expiresAt / 1000),\n          nbf: Math.floor(validAt / 1000),\n        }),\n        jwtSecret,\n        {\n          algorithm,\n        } as SignOptions,\n        (err, token: string | undefined) => {\n          if (err) {\n            reject(YError.wrap(err as Error, 'E_JWT', payload));\n            return;\n          }\n          resolve(token as string);\n        },\n      );\n    });\n\n    return {\n      token,\n      issuedAt,\n      expiresAt,\n      validAt,\n    };\n  }\n\n  /**\n   * Verify and decode the given token\n   * @memberof JWTService\n   * @param  {String}   [token]  The token to decode\n   * @return {Promise<Object>}\n   * A promise to be resolved with the token payload.\n   * @example\n   * const payload = await jwt.verify('my.jwt.token');\n   */\n  async function verify(token: string): Promise<PAYLOAD> {\n    return new Promise((resolve, reject) => {\n      jwt.verify(\n        token,\n        jwtSecret,\n        {\n          algorithms: JWT.algorithms as unknown as Algorithm[],\n          clockTolerance: Math.floor(JWT_TOLERANCE / 1000),\n          clockTimestamp: Math.floor(time() / 1000),\n        },\n        (err, decoded) => {\n          if (err) {\n            if ('TokenExpiredError' === err.name) {\n              reject(YError.wrap(err, 'E_JWT_EXPIRED', token));\n              return;\n            }\n            if ('JsonWebTokenError' === err.name) {\n              reject(YError.wrap(err, 'E_JWT_MALFORMED', token));\n              return;\n            }\n            reject(YError.wrap(err, 'E_JWT', token));\n            return;\n          }\n          resolve(decoded as PAYLOAD);\n        },\n      );\n    });\n  }\n\n  log('info', 'JWT service initialized!');\n\n  return jwtService;\n}\n\nfunction noop(...args: unknown[]) {\n  args;\n}\n\nfunction readMS(\n  value: string | undefined,\n  errorCode: string,\n  defaultValue: number | undefined = undefined,\n): number {\n  const isRequired = 'undefined' === typeof defaultValue;\n  const hasValue = 'undefined' !== typeof value;\n  const finalValue = hasValue ? (value as string) : '' + defaultValue;\n\n  if (isRequired && !hasValue) {\n    throw new YError(errorCode, value);\n  }\n\n  try {\n    const computedDuration = ms(finalValue);\n\n    if ('undefined' === typeof computedDuration) {\n      throw new YError(errorCode, value);\n    }\n\n    return computedDuration;\n  } catch (err) {\n    throw YError.wrap(err as Error, errorCode, finalValue);\n  }\n}\n"],"mappings":"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"}