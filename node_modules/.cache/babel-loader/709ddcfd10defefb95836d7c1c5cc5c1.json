{"ast":null,"code":"import React, { useRef, useEffect, useState } from 'react';\nimport ReactDom from 'react-dom';\nimport cx from 'classnames';\nimport noScroll from 'no-scroll';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar CloseIcon = function CloseIcon(_ref) {\n  var classes = _ref.classes,\n    classNames = _ref.classNames,\n    styles = _ref.styles,\n    id = _ref.id,\n    closeIcon = _ref.closeIcon,\n    onClickCloseIcon = _ref.onClickCloseIcon;\n  return React.createElement(\"button\", {\n    id: id,\n    className: cx(classes.closeButton, classNames == null ? void 0 : classNames.closeButton),\n    style: styles == null ? void 0 : styles.closeButton,\n    onClick: onClickCloseIcon,\n    \"data-testid\": \"close-button\"\n  }, closeIcon ? closeIcon : React.createElement(\"svg\", {\n    className: classNames == null ? void 0 : classNames.closeIcon,\n    style: styles == null ? void 0 : styles.closeIcon,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 28,\n    height: 28,\n    viewBox: \"0 0 36 36\",\n    \"data-testid\": \"close-icon\"\n  }, React.createElement(\"path\", {\n    d: \"M28.5 9.62L26.38 7.5 18 15.88 9.62 7.5 7.5 9.62 15.88 18 7.5 26.38l2.12 2.12L18 20.12l8.38 8.38 2.12-2.12L20.12 18z\"\n  })));\n};\nvar _modals = [];\n/**\r\n * Handle the order of the modals.\r\n * Inspired by the material-ui implementation.\r\n */\n\nvar modalManager = {\n  /**\r\n   * Return the modals array\r\n   */\n  modals: function modals() {\n    return _modals;\n  },\n  /**\r\n   * Register a new modal\r\n   */\n  add: function add(newModal, blockScroll) {\n    if (_modals.findIndex(function (modal) {\n      return modal.element === newModal;\n    }) === -1) {\n      _modals.push({\n        element: newModal,\n        blockScroll: blockScroll\n      });\n    }\n  },\n  /**\r\n   * Remove a modal\r\n   */\n  remove: function remove(oldModal) {\n    var index = _modals.findIndex(function (modal) {\n      return modal.element === oldModal;\n    });\n    if (index !== -1) {\n      _modals.splice(index, 1);\n    }\n  },\n  /**\r\n   * Check if the modal is the first one on the screen\r\n   */\n  isTopModal: function isTopModal(modal) {\n    var _modals2;\n    return !!_modals.length && ((_modals2 = _modals[_modals.length - 1]) == null ? void 0 : _modals2.element) === modal;\n  }\n};\nvar isBrowser = typeof window !== 'undefined';\nvar blockNoScroll = function blockNoScroll() {\n  noScroll.on();\n};\nvar unblockNoScroll = function unblockNoScroll() {\n  // Restore the scroll only if there is no modal on the screen\n  // We filter the modals that are not affecting the scroll\n  var modals = modalManager.modals().filter(function (modal) {\n    return modal.blockScroll;\n  });\n  if (modals.length === 0) {\n    noScroll.off();\n  }\n};\n\n// https://github.com/alexandrzavalii/focus-trap-js/blob/master/src/index.js v1.0.9\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])'];\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\nfunction getAllTabbingElements(parentElem) {\n  var tabbableNodes = parentElem.querySelectorAll(candidateSelectors.join(','));\n  var onlyTabbable = [];\n  for (var i = 0; i < tabbableNodes.length; i++) {\n    var node = tabbableNodes[i];\n    if (!node.disabled && getTabindex(node) > -1 && !isHidden(node)) {\n      onlyTabbable.push(node);\n    }\n  }\n  return onlyTabbable;\n}\nfunction tabTrappingKey(event, parentElem) {\n  // check if current event keyCode is tab\n  if (!event || event.key !== 'Tab') return;\n  if (!parentElem || !parentElem.contains) {\n    if (process && process.env.NODE_ENV === 'development') {\n      console.warn('focus-trap-js: parent element is not defined');\n    }\n    return false;\n  }\n  if (!parentElem.contains(event.target)) {\n    return false;\n  }\n  var allTabbingElements = getAllTabbingElements(parentElem);\n  var firstFocusableElement = allTabbingElements[0];\n  var lastFocusableElement = allTabbingElements[allTabbingElements.length - 1];\n  if (event.shiftKey && event.target === firstFocusableElement) {\n    lastFocusableElement.focus();\n    event.preventDefault();\n    return true;\n  } else if (!event.shiftKey && event.target === lastFocusableElement) {\n    firstFocusableElement.focus();\n    event.preventDefault();\n    return true;\n  }\n  return false;\n}\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return tabIndex correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\nfunction isContentEditable(node) {\n  return node.getAttribute('contentEditable');\n}\nvar FocusTrap = function FocusTrap(_ref) {\n  var container = _ref.container;\n  var refLastFocus = useRef();\n  /**\r\n   * Handle focus lock on the modal\r\n   */\n\n  useEffect(function () {\n    var handleKeyEvent = function handleKeyEvent(event) {\n      if (container == null ? void 0 : container.current) {\n        tabTrappingKey(event, container.current);\n      }\n    };\n    if (isBrowser) {\n      document.addEventListener('keydown', handleKeyEvent);\n    } // On mount we focus on the first focusable element in the modal if there is one\n\n    if (isBrowser && (container == null ? void 0 : container.current)) {\n      var allTabbingElements = getAllTabbingElements(container.current);\n      if (allTabbingElements[0]) {\n        // First we save the last focused element\n        // only if it's a focusable element\n        if (candidateSelectors.findIndex(function (selector) {\n          var _document$activeEleme;\n          return (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.matches(selector);\n        }) !== -1) {\n          refLastFocus.current = document.activeElement;\n        }\n        allTabbingElements[0].focus();\n      }\n    }\n    return function () {\n      if (isBrowser) {\n        var _refLastFocus$current;\n        document.removeEventListener('keydown', handleKeyEvent); // On unmount we restore the focus to the last focused element\n\n        (_refLastFocus$current = refLastFocus.current) == null ? void 0 : _refLastFocus$current.focus();\n      }\n    };\n  }, [container]);\n  return null;\n};\nvar classes = {\n  overlay: 'react-responsive-modal-overlay',\n  modal: 'react-responsive-modal-modal',\n  modalCenter: 'react-responsive-modal-modalCenter',\n  closeButton: 'react-responsive-modal-closeButton',\n  animationIn: 'react-responsive-modal-fadeIn',\n  animationOut: 'react-responsive-modal-fadeOut'\n};\nvar Modal = function Modal(_ref) {\n  var _classNames$animation, _classNames$animation2;\n  var open = _ref.open,\n    center = _ref.center,\n    _ref$blockScroll = _ref.blockScroll,\n    blockScroll = _ref$blockScroll === void 0 ? true : _ref$blockScroll,\n    _ref$closeOnEsc = _ref.closeOnEsc,\n    closeOnEsc = _ref$closeOnEsc === void 0 ? true : _ref$closeOnEsc,\n    _ref$closeOnOverlayCl = _ref.closeOnOverlayClick,\n    closeOnOverlayClick = _ref$closeOnOverlayCl === void 0 ? true : _ref$closeOnOverlayCl,\n    container = _ref.container,\n    _ref$showCloseIcon = _ref.showCloseIcon,\n    showCloseIcon = _ref$showCloseIcon === void 0 ? true : _ref$showCloseIcon,\n    closeIconId = _ref.closeIconId,\n    closeIcon = _ref.closeIcon,\n    _ref$focusTrapped = _ref.focusTrapped,\n    focusTrapped = _ref$focusTrapped === void 0 ? true : _ref$focusTrapped,\n    _ref$animationDuratio = _ref.animationDuration,\n    animationDuration = _ref$animationDuratio === void 0 ? 500 : _ref$animationDuratio,\n    classNames = _ref.classNames,\n    styles = _ref.styles,\n    _ref$role = _ref.role,\n    role = _ref$role === void 0 ? 'dialog' : _ref$role,\n    ariaDescribedby = _ref.ariaDescribedby,\n    ariaLabelledby = _ref.ariaLabelledby,\n    modalId = _ref.modalId,\n    onClose = _ref.onClose,\n    onEscKeyDown = _ref.onEscKeyDown,\n    onOverlayClick = _ref.onOverlayClick,\n    onAnimationEnd = _ref.onAnimationEnd,\n    children = _ref.children;\n  var refModal = useRef(null);\n  var refShouldClose = useRef(null);\n  var refContainer = useRef(null); // Lazily create the ref instance\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n\n  if (refContainer.current === null && isBrowser) {\n    refContainer.current = document.createElement('div');\n  } // The value should be false for srr, that way when the component is hydrated client side,\n  // it will match the server rendered content\n\n  var _useState = useState(false),\n    showPortal = _useState[0],\n    setShowPortal = _useState[1];\n  var handleOpen = function handleOpen() {\n    modalManager.add(refContainer.current, blockScroll);\n    if (blockScroll) {\n      blockNoScroll();\n    }\n    if (refContainer.current && !container && !document.body.contains(refContainer.current)) {\n      document.body.appendChild(refContainer.current);\n    }\n    document.addEventListener('keydown', handleKeydown);\n  };\n  var handleClose = function handleClose() {\n    modalManager.remove(refContainer.current);\n    if (blockScroll) {\n      unblockNoScroll();\n    }\n    if (refContainer.current && !container && document.body.contains(refContainer.current)) {\n      document.body.removeChild(refContainer.current);\n    }\n    document.removeEventListener('keydown', handleKeydown);\n  };\n  var handleKeydown = function handleKeydown(event) {\n    // Only the last modal need to be escaped when pressing the esc key\n    if (event.keyCode !== 27 || !modalManager.isTopModal(refContainer.current)) {\n      return;\n    }\n    onEscKeyDown == null ? void 0 : onEscKeyDown(event);\n    if (closeOnEsc) {\n      onClose();\n    }\n  };\n  useEffect(function () {\n    return function () {\n      // When the component is unmounted directly we want to unblock the scroll\n      if (showPortal) {\n        handleClose();\n      }\n    };\n  }, [showPortal]);\n  useEffect(function () {\n    // If the open prop is changing, we need to open the modal\n    // This is also called on the first render if the open prop is true when the modal is created\n    if (open && !showPortal) {\n      setShowPortal(true);\n      handleOpen();\n    }\n  }, [open]);\n  var handleClickOverlay = function handleClickOverlay(event) {\n    if (refShouldClose.current === null) {\n      refShouldClose.current = true;\n    }\n    if (!refShouldClose.current) {\n      refShouldClose.current = null;\n      return;\n    }\n    onOverlayClick == null ? void 0 : onOverlayClick(event);\n    if (closeOnOverlayClick) {\n      onClose();\n    }\n    refShouldClose.current = null;\n  };\n  var handleModalEvent = function handleModalEvent() {\n    refShouldClose.current = false;\n  };\n  var handleClickCloseIcon = function handleClickCloseIcon() {\n    onClose();\n  };\n  var handleAnimationEnd = function handleAnimationEnd() {\n    if (!open) {\n      setShowPortal(false);\n    }\n    onAnimationEnd == null ? void 0 : onAnimationEnd();\n  };\n  var containerModal = container || refContainer.current;\n  return showPortal && containerModal ? ReactDom.createPortal(React.createElement(\"div\", {\n    style: _extends({\n      animation: (open ? (_classNames$animation = classNames == null ? void 0 : classNames.animationIn) != null ? _classNames$animation : classes.animationIn : (_classNames$animation2 = classNames == null ? void 0 : classNames.animationOut) != null ? _classNames$animation2 : classes.animationOut) + \" \" + animationDuration + \"ms\"\n    }, styles == null ? void 0 : styles.overlay),\n    className: cx(classes.overlay, classNames == null ? void 0 : classNames.overlay),\n    onClick: handleClickOverlay,\n    onAnimationEnd: handleAnimationEnd,\n    \"data-testid\": \"overlay\"\n  }, React.createElement(\"div\", {\n    ref: refModal,\n    className: cx(classes.modal, center && classes.modalCenter, classNames == null ? void 0 : classNames.modal),\n    style: styles == null ? void 0 : styles.modal,\n    onMouseDown: handleModalEvent,\n    onMouseUp: handleModalEvent,\n    onClick: handleModalEvent,\n    id: modalId,\n    role: role,\n    \"aria-modal\": \"true\",\n    \"aria-labelledby\": ariaLabelledby,\n    \"aria-describedby\": ariaDescribedby,\n    \"data-testid\": \"modal\"\n  }, focusTrapped && React.createElement(FocusTrap, {\n    container: refModal\n  }), children, showCloseIcon && React.createElement(CloseIcon, {\n    classes: classes,\n    classNames: classNames,\n    styles: styles,\n    closeIcon: closeIcon,\n    onClickCloseIcon: handleClickCloseIcon,\n    id: closeIconId\n  }))), containerModal) : null;\n};\nexport default Modal;\nexport { Modal };","map":{"version":3,"sources":["../src/CloseIcon.tsx","../src/modalManager.ts","../src/utils.ts","../src/lib/focusTrapJs.ts","../src/FocusTrap.tsx","../src/index.tsx"],"names":["CloseIcon","classes","classNames","styles","id","closeIcon","onClickCloseIcon","className","cx","closeButton","style","onClick","xmlns","width","height","viewBox","d","modals","add","newModal","blockScroll","findIndex","modal","element","push","remove","oldModal","index","splice","isTopModal","length","isBrowser","window","blockNoScroll","noScroll","on","unblockNoScroll","filter","off","candidateSelectors","isHidden","node","offsetParent","getComputedStyle","visibility","getAllTabbingElements","parentElem","tabbableNodes","querySelectorAll","join","onlyTabbable","i","disabled","getTabindex","tabTrappingKey","event","key","contains","process","env","NODE_ENV","console","warn","target","allTabbingElements","firstFocusableElement","lastFocusableElement","shiftKey","focus","preventDefault","tabindexAttr","parseInt","getAttribute","isNaN","isContentEditable","tabIndex","FocusTrap","container","refLastFocus","useRef","useEffect","handleKeyEvent","current","document","addEventListener","selector","activeElement","matches","removeEventListener","overlay","modalCenter","animationIn","animationOut","Modal","open","center","closeOnEsc","closeOnOverlayClick","showCloseIcon","closeIconId","focusTrapped","animationDuration","role","ariaDescribedby","ariaLabelledby","modalId","onClose","onEscKeyDown","onOverlayClick","onAnimationEnd","children","refModal","refShouldClose","refContainer","createElement","showPortal","setShowPortal","useState","handleOpen","modalManager","body","appendChild","handleKeydown","handleClose","removeChild","keyCode","handleClickOverlay","handleModalEvent","handleClickCloseIcon","handleAnimationEnd","containerModal","createPortal","animation","ref","onMouseDown","onMouseUp"],"mappings":"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","sourcesContent":["import React from 'react';\nimport cx from 'classnames';\n\ninterface CloseIconProps {\n  id?: string;\n  closeIcon?: React.ReactNode;\n  styles?: {\n    closeButton?: React.CSSProperties;\n    closeIcon?: React.CSSProperties;\n  };\n  classNames?: {\n    closeButton?: string;\n    closeIcon?: string;\n  };\n  classes: {\n    closeButton?: string;\n  };\n  onClickCloseIcon: () => void;\n}\n\nconst CloseIcon = ({\n  classes,\n  classNames,\n  styles,\n  id,\n  closeIcon,\n  onClickCloseIcon,\n}: CloseIconProps) => (\n  <button\n    id={id}\n    className={cx(classes.closeButton, classNames?.closeButton)}\n    style={styles?.closeButton}\n    onClick={onClickCloseIcon}\n    data-testid=\"close-button\"\n  >\n    {closeIcon ? (\n      closeIcon\n    ) : (\n      <svg\n        className={classNames?.closeIcon}\n        style={styles?.closeIcon}\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width={28}\n        height={28}\n        viewBox=\"0 0 36 36\"\n        data-testid=\"close-icon\"\n      >\n        <path d=\"M28.5 9.62L26.38 7.5 18 15.88 9.62 7.5 7.5 9.62 15.88 18 7.5 26.38l2.12 2.12L18 20.12l8.38 8.38 2.12-2.12L20.12 18z\" />\n      </svg>\n    )}\n  </button>\n);\n\nexport default CloseIcon;\n","const modals: { element: HTMLDivElement; blockScroll: boolean }[] = [];\n\n/**\n * Handle the order of the modals.\n * Inspired by the material-ui implementation.\n */\nexport default {\n  /**\n   * Return the modals array\n   */\n  modals: () => modals,\n\n  /**\n   * Register a new modal\n   */\n  add: (newModal: HTMLDivElement, blockScroll: boolean) => {\n    if (modals.findIndex((modal) => modal.element === newModal) === -1) {\n      modals.push({ element: newModal, blockScroll });\n    }\n  },\n\n  /**\n   * Remove a modal\n   */\n  remove: (oldModal: HTMLDivElement) => {\n    const index = modals.findIndex((modal) => modal.element === oldModal);\n    if (index !== -1) {\n      modals.splice(index, 1);\n    }\n  },\n\n  /**\n   * Check if the modal is the first one on the screen\n   */\n  isTopModal: (modal: HTMLDivElement) =>\n    !!modals.length && modals[modals.length - 1]?.element === modal,\n};\n","import noScroll from 'no-scroll';\nimport modalManager from './modalManager';\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport const blockNoScroll = () => {\n  noScroll.on();\n};\n\nexport const unblockNoScroll = () => {\n  // Restore the scroll only if there is no modal on the screen\n  // We filter the modals that are not affecting the scroll\n  const modals = modalManager.modals().filter((modal) => modal.blockScroll);\n  if (modals.length === 0) {\n    noScroll.off();\n  }\n};\n","// https://github.com/alexandrzavalii/focus-trap-js/blob/master/src/index.js v1.0.9\n\nexport const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\n\nfunction isHidden(node: any) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return (\n    node.offsetParent === null || getComputedStyle(node).visibility === 'hidden'\n  );\n}\n\nexport function getAllTabbingElements(parentElem: any) {\n  var tabbableNodes = parentElem.querySelectorAll(candidateSelectors.join(','));\n  var onlyTabbable = [];\n  for (var i = 0; i < tabbableNodes.length; i++) {\n    var node = tabbableNodes[i];\n    if (!node.disabled && getTabindex(node) > -1 && !isHidden(node)) {\n      onlyTabbable.push(node);\n    }\n  }\n  return onlyTabbable;\n}\n\nexport function tabTrappingKey(event: any, parentElem: any) {\n  // check if current event keyCode is tab\n  if (!event || event.key !== 'Tab') return;\n\n  if (!parentElem || !parentElem.contains) {\n    if (process && process.env.NODE_ENV === 'development') {\n      console.warn('focus-trap-js: parent element is not defined');\n    }\n    return false;\n  }\n\n  if (!parentElem.contains(event.target)) {\n    return false;\n  }\n\n  var allTabbingElements = getAllTabbingElements(parentElem);\n  var firstFocusableElement = allTabbingElements[0];\n  var lastFocusableElement = allTabbingElements[allTabbingElements.length - 1];\n\n  if (event.shiftKey && event.target === firstFocusableElement) {\n    lastFocusableElement.focus();\n    event.preventDefault();\n    return true;\n  } else if (!event.shiftKey && event.target === lastFocusableElement) {\n    firstFocusableElement.focus();\n    event.preventDefault();\n    return true;\n  }\n  return false;\n}\n\nfunction getTabindex(node: any) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return tabIndex correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction isContentEditable(node: any) {\n  return node.getAttribute('contentEditable');\n}\n","import { useEffect, useRef } from 'react';\nimport { isBrowser } from './utils';\nimport {\n  tabTrappingKey,\n  candidateSelectors,\n  getAllTabbingElements,\n} from './lib/focusTrapJs';\n\ninterface FocusTrapProps {\n  container?: React.RefObject<HTMLElement> | null;\n}\n\nexport const FocusTrap = ({ container }: FocusTrapProps) => {\n  const refLastFocus = useRef<HTMLElement | null>();\n  /**\n   * Handle focus lock on the modal\n   */\n  useEffect(() => {\n    const handleKeyEvent = (event: KeyboardEvent) => {\n      if (container?.current) {\n        tabTrappingKey(event, container.current);\n      }\n    };\n\n    if (isBrowser) {\n      document.addEventListener('keydown', handleKeyEvent);\n    }\n    // On mount we focus on the first focusable element in the modal if there is one\n    if (isBrowser && container?.current) {\n      const allTabbingElements = getAllTabbingElements(container.current);\n      if (allTabbingElements[0]) {\n        // First we save the last focused element\n        // only if it's a focusable element\n        if (\n          candidateSelectors.findIndex((selector) =>\n            document.activeElement?.matches(selector)\n          ) !== -1\n        ) {\n          refLastFocus.current = document.activeElement as HTMLElement;\n        }\n        allTabbingElements[0].focus();\n      }\n    }\n    return () => {\n      if (isBrowser) {\n        document.removeEventListener('keydown', handleKeyEvent);\n        // On unmount we restore the focus to the last focused element\n        refLastFocus.current?.focus();\n      }\n    };\n  }, [container]);\n\n  return null;\n};\n","import React, { useEffect, useState, useRef } from 'react';\nimport ReactDom from 'react-dom';\nimport cx from 'classnames';\nimport CloseIcon from './CloseIcon';\nimport { FocusTrap } from './FocusTrap';\nimport modalManager from './modalManager';\nimport { isBrowser, blockNoScroll, unblockNoScroll } from './utils';\n\nconst classes = {\n  overlay: 'react-responsive-modal-overlay',\n  modal: 'react-responsive-modal-modal',\n  modalCenter: 'react-responsive-modal-modalCenter',\n  closeButton: 'react-responsive-modal-closeButton',\n  animationIn: 'react-responsive-modal-fadeIn',\n  animationOut: 'react-responsive-modal-fadeOut',\n};\n\nexport interface ModalProps {\n  /**\n   * Control if the modal is open or not.\n   */\n  open: boolean;\n  /**\n   * Should the dialog be centered.\n   *\n   * Default to false.\n   */\n  center?: boolean;\n  /**\n   * Is the modal closable when user press esc key.\n   *\n   * Default to true.\n   */\n  closeOnEsc?: boolean;\n  /**\n   * Is the modal closable when user click on overlay.\n   *\n   * Default to true.\n   */\n  closeOnOverlayClick?: boolean;\n  /**\n   * Whether to block scrolling when dialog is open.\n   *\n   * Default to true.\n   */\n  blockScroll?: boolean;\n  /**\n   * Show the close icon.\n   */\n  showCloseIcon?: boolean;\n  /**\n   * id attribute for the close icon button.\n   */\n  closeIconId?: string;\n  /**\n   * Custom icon to render (svg, img, etc...).\n   */\n  closeIcon?: React.ReactNode;\n  /**\n   * When the modal is open, trap focus within it.\n   *\n   * Default to true.\n   */\n  focusTrapped?: boolean;\n  /**\n   * You can specify a container prop which should be of type `Element`.\n   * The portal will be rendered inside that element.\n   * The default behavior will create a div node and render it at the at the end of document.body.\n   */\n  container?: Element;\n  /**\n   * An object containing classNames to style the modal.\n   */\n  classNames?: {\n    overlay?: string;\n    modal?: string;\n    closeButton?: string;\n    closeIcon?: string;\n    animationIn?: string;\n    animationOut?: string;\n  };\n  /**\n   * An object containing the styles objects to style the modal.\n   */\n  styles?: {\n    overlay?: React.CSSProperties;\n    modal?: React.CSSProperties;\n    closeButton?: React.CSSProperties;\n    closeIcon?: React.CSSProperties;\n  };\n  /**\n   * Animation duration in milliseconds.\n   *\n   * Default to 500.\n   */\n  animationDuration?: number;\n  /**\n   * ARIA role for modal\n   *\n   * Default to 'dialog'.\n   */\n  role?: string;\n  /**\n   * ARIA label for modal\n   */\n  ariaLabelledby?: string;\n  /**\n   * ARIA description for modal\n   */\n  ariaDescribedby?: string;\n  /**\n   * id attribute for modal\n   */\n  modalId?: string;\n  /**\n   * Callback fired when the Modal is requested to be closed by a click on the overlay or when user press esc key.\n   */\n  onClose: () => void;\n  /**\n   * Callback fired when the escape key is pressed.\n   */\n  onEscKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Callback fired when the overlay is clicked.\n   */\n  onOverlayClick?: (\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => void;\n  /**\n   * Callback fired when the Modal has exited and the animation is finished.\n   */\n  onAnimationEnd?: () => void;\n  children?: React.ReactNode;\n}\n\nexport const Modal = ({\n  open,\n  center,\n  blockScroll = true,\n  closeOnEsc = true,\n  closeOnOverlayClick = true,\n  container,\n  showCloseIcon = true,\n  closeIconId,\n  closeIcon,\n  focusTrapped = true,\n  animationDuration = 500,\n  classNames,\n  styles,\n  role = 'dialog',\n  ariaDescribedby,\n  ariaLabelledby,\n  modalId,\n  onClose,\n  onEscKeyDown,\n  onOverlayClick,\n  onAnimationEnd,\n  children,\n}: ModalProps) => {\n  const refModal = useRef<HTMLDivElement>(null);\n  const refShouldClose = useRef<boolean | null>(null);\n  const refContainer = useRef<HTMLDivElement | null>(null);\n  // Lazily create the ref instance\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n  if (refContainer.current === null && isBrowser) {\n    refContainer.current = document.createElement('div');\n  }\n\n  // The value should be false for srr, that way when the component is hydrated client side,\n  // it will match the server rendered content\n  const [showPortal, setShowPortal] = useState(false);\n\n  const handleOpen = () => {\n    modalManager.add(refContainer.current!, blockScroll);\n    if (blockScroll) {\n      blockNoScroll();\n    }\n    if (\n      refContainer.current &&\n      !container &&\n      !document.body.contains(refContainer.current)\n    ) {\n      document.body.appendChild(refContainer.current);\n    }\n    document.addEventListener('keydown', handleKeydown);\n  };\n\n  const handleClose = () => {\n    modalManager.remove(refContainer.current!);\n    if (blockScroll) {\n      unblockNoScroll();\n    }\n    if (\n      refContainer.current &&\n      !container &&\n      document.body.contains(refContainer.current)\n    ) {\n      document.body.removeChild(refContainer.current);\n    }\n    document.removeEventListener('keydown', handleKeydown);\n  };\n\n  const handleKeydown = (event: KeyboardEvent) => {\n    // Only the last modal need to be escaped when pressing the esc key\n    if (\n      event.keyCode !== 27 ||\n      !modalManager.isTopModal(refContainer.current!)\n    ) {\n      return;\n    }\n\n    onEscKeyDown?.(event);\n\n    if (closeOnEsc) {\n      onClose();\n    }\n  };\n\n  useEffect(() => {\n    return () => {\n      // When the component is unmounted directly we want to unblock the scroll\n      if (showPortal) {\n        handleClose();\n      }\n    };\n  }, [showPortal]);\n\n  useEffect(() => {\n    // If the open prop is changing, we need to open the modal\n    // This is also called on the first render if the open prop is true when the modal is created\n    if (open && !showPortal) {\n      setShowPortal(true);\n      handleOpen();\n    }\n  }, [open]);\n\n  const handleClickOverlay = (\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => {\n    if (refShouldClose.current === null) {\n      refShouldClose.current = true;\n    }\n\n    if (!refShouldClose.current) {\n      refShouldClose.current = null;\n      return;\n    }\n\n    onOverlayClick?.(event);\n\n    if (closeOnOverlayClick) {\n      onClose();\n    }\n\n    refShouldClose.current = null;\n  };\n\n  const handleModalEvent = () => {\n    refShouldClose.current = false;\n  };\n\n  const handleClickCloseIcon = () => {\n    onClose();\n  };\n\n  const handleAnimationEnd = () => {\n    if (!open) {\n      setShowPortal(false);\n    }\n\n    onAnimationEnd?.();\n  };\n\n  const containerModal = container || refContainer.current;\n\n  return showPortal && containerModal\n    ? ReactDom.createPortal(\n        <div\n          style={{\n            animation: `${\n              open\n                ? classNames?.animationIn ?? classes.animationIn\n                : classNames?.animationOut ?? classes.animationOut\n            } ${animationDuration}ms`,\n            ...styles?.overlay,\n          }}\n          className={cx(classes.overlay, classNames?.overlay)}\n          onClick={handleClickOverlay}\n          onAnimationEnd={handleAnimationEnd}\n          data-testid=\"overlay\"\n        >\n          <div\n            ref={refModal}\n            className={cx(\n              classes.modal,\n              center && classes.modalCenter,\n              classNames?.modal\n            )}\n            style={styles?.modal}\n            onMouseDown={handleModalEvent}\n            onMouseUp={handleModalEvent}\n            onClick={handleModalEvent}\n            id={modalId}\n            role={role}\n            aria-modal=\"true\"\n            aria-labelledby={ariaLabelledby}\n            aria-describedby={ariaDescribedby}\n            data-testid=\"modal\"\n          >\n            {focusTrapped && <FocusTrap container={refModal} />}\n            {children}\n            {showCloseIcon && (\n              <CloseIcon\n                classes={classes}\n                classNames={classNames}\n                styles={styles}\n                closeIcon={closeIcon}\n                onClickCloseIcon={handleClickCloseIcon}\n                id={closeIconId}\n              />\n            )}\n          </div>\n        </div>,\n        containerModal\n      )\n    : null;\n};\n\nexport default Modal;\n"]},"metadata":{},"sourceType":"module"}